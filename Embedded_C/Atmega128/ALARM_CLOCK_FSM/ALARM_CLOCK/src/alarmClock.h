#ifndef ALARMCLOCK_H_
#define ALARMCLOCK_H__

/*INCLUDES *******************************************************************/
#include "ses_common.h"
#include <avr/io.h>
#include <util/delay.h>
#include "ses_button.h"
#include "ses_scheduler.h"
#include "ses_lcd.h"
#include "ses_led.h"
#include "ses_rotary.h"


/* TYPES ********************************************************************/
/**
 * Possible clock states and digits
 */
enum {
	HOURS =0 , MINTUES = 1, SECONDS = 2, ALL =3, UNINITIALIZED = 4
};

typedef uint8_t fsmReturnStatus; //< typedef to be used  with above enum

/** typedef for state event handler functions */
typedef struct fsm_s Fsm;                              //< typedef for alarm clock state machine
typedef struct event_s Event;                          //< event type for alarm clock fsm
typedef fsmReturnStatus (*State)(Fsm*, const Event*);

struct fsm_s {
     State state;             //< current state, pointer to event handler
     bool isAlarmEnabled;     //< flag for the alarm status
     struct time_t timeSet;   //< multi-purpose var for system time and alarm time
};

/** return values */
enum {
     RET_HANDLED,             //< event was handled
     RET_IGNORED,             //< event was ignored; not used in this implementation
     RET_TRANSITION           //< event was handled and a state transition occurred
};

/**
 * each event carry a certain signal idintefied  by its value
 */
struct event_s 
{
     uint8_t signal;          //< identifies the type of event
};

/**
 * All possibile events
 */
enum {
     ENTRY = 0 , EXIT = 1,
     JOYSTICK_PRESSED = 2 , ROTARY_PRESSED = 3, ROTARY_LEFT_PRESSED = 10 ,            // These are external events generated by external devices(i.e buttons)
     UPDATE_CLOCK =4, STOP_ALARM =5, ALARM_EXPIRED = 6, ALARM_CLOCKTIME_MATCH = 7, ALARM_COMPARE = 8,
     RETURN = 9, 
};
/* FUNCTION PROTOTYPES *******************************************************/
/**
 * dispatches events to state machine, called in application
 * @param fsm is a pointer of type struct, which points the current system state.
 * @param event is a pointer of type struct, which points to the current event. 
 */
inline static void fsm_dispatch(Fsm * fsm, const Event * event)
{
     static Event entryEvent = { .signal = ENTRY};
     static Event exitEvent = {.signal = EXIT};
     State s = fsm->state;
     fsmReturnStatus r = fsm->state(fsm, event);
     if (r == RET_TRANSITION)
     {
          s(fsm, &exitEvent);           //< call exit action of last state
          fsm->state(fsm, &entryEvent); //< call entry action of new state
     }
}

/**
 * sets and calls initial state of state machine
 * @param fsm is a pointer of type struct, which points the current system state.
 * @param init is a pointer of type struct, which points to the initial state (Function). 
 */
inline void fsm_init(Fsm * fsm, State init)
{
     Event entryEvent = {.signal = ENTRY};
     fsm->state = init;
     fsm->state(fsm, &entryEvent);
}

/**
 * Tasks(Events), that will be added to the scheduler as a Qeue
 * @param param is set to void pointer to match scheduler task discriptor 
 */

void timerDispatch(void * param);          // Triggered every second, to update clock display or to check alarm time match
void alarmActivationDispatch(void);        // Triggered when alarm compare match happens
void alarmTimeoutDispatch(void * param);   // Triggered after 5 seconds (Alarm expiration time)

 //*********** When external devices (switches or BUttons) events added to the scheduler qeue ***********

void add_rotaryDispatch(void);
void add_joystickDispatch(void);
void add_rotaryClockWiseDispatch(void);
void add_rotaryCounterClockWiseDispatch(void);

void joystickPressedDispatch(void * param);
void rotaryPressedDispatch(void * param);
void rotaryCounterClockWiseDispatch(void * param);
void rotaryClockWiseDispatch(void * param);

/**
 * All system states 
 * @param fsm is a pointer of type struct, which points the current system state.
 * @param event is a pointer of type struct, which points to the current event. 
 */
fsmReturnStatus clock_running(Fsm * fsm, const Event * event);
fsmReturnStatus alarm_set_hours(Fsm * fsm, const Event * event);
fsmReturnStatus clock_set_hours(Fsm * fsm, const Event * event);
fsmReturnStatus alarm_set_minutes(Fsm * fsm, const Event * event);
fsmReturnStatus clock_set_minutes(Fsm * fsm, const Event * event);
fsmReturnStatus clock_alarm_enable(Fsm * fsm, const Event * event);
fsmReturnStatus clock_initialization(Fsm * fsm, const Event * event);
fsmReturnStatus clock_alarm_activated(Fsm * fsm, const Event * event);

#endif /* ALARMCLOCK_H_ */
